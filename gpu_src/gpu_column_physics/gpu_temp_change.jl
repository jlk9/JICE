# Written by Joseph Kump (josek97@utexas.edu)
# Computes the thermodynamic temperature changes in once column
# of sea ice

# Runs a single time step of the temperature changes using FDM
@inline function step_temp_change(N_c, N_i, N_s, N_layers, H_s, S, T_frz, Δh, T_old, T_new, c_i, K, K̄, I_pen, F_0, dF_0, maindiag, subdiag, supdiag, Δt, step)

    #=
    # Getting the average thicknesses of each layer:
    for i in 1:(jcolumn.N_i+jcolumn.N_s)
        jcolumn.Δh̄[i] = (jcolumn.Δh[i] + jcolumn.Δh[i+1]) ./ 2
    end
    =#
    # Ice thermal conductivity (length N_i+1)
    generate_K(K, N_c, N_s, N_layers, H_s, S, T_old)
    
    # Specific heat (length N_i+1), generated by formula
    generate_c_i(c_i, N_c, N_s, N_layers, S, T_old, T_new)
    
    # Get the Matrix and RHS:
    generate_maindiag_rhs(N_c, N_i, N_s, N_layers, H_s, Δh, c_i, K, K̄, dF_0[(step-1)*N_c+1:step*N_c], F_0, T_frz, I_pen, maindiag, T_new, T_old, Δt)
    generate_subdiag_supdiag(N_c, N_s, N_layers, Δh, c_i, K̄, subdiag, supdiag, T_old, Δt)

    batched_tridiagonal_solve(T_new, N_layers-1, N_c, maindiag, subdiag, supdiag)
    
    return nothing
end

# Produces the main diagonal of the matrices for the tridiagonal solve and temperature changes
@inline function generate_maindiag_rhs(N_c, N_i, N_s, N_layers, H_s, Δh, c_i, K, K̄, dF_0, F_0, T_frz, I_pen, maindiag, rhs, T_old, Δt)

    #=
    # First get K̄:
    for col in 1:N_c
        index = (col-1) * N_layers
        for k in 1:(N_layers-1)
            K̄[index+k] = (2*K[index+k]*K[index+k+1]) / (Δh[index+k+1]*K[index+k] + Δh[index+k]*K[index+k+1])
        end
        K̄[index+N_layers] = 0.5K[index+N_layers]
    end
    =#
    # First get K̄, then fill in entries of maindiag::
    for index in 1:(N_c*N_layers)
        col = ((index-1) ÷ N_layers) + 1
        k   = (index-1) % N_layers

        if index % N_layers == 0
            K̄[index] = 0.5K[index]
        else
            K̄[index] = (2*K[index]*K[index+1]) / (Δh[index+1]*K[index] + Δh[index]*K[index+1])
        end

        # Initialize maindiag as 1's, rhs as 0's:
        maindiag[index] = 1.0
        rhs[index]      = 0.0

        # Compute η_k (Δh index special for lower boundary), then multiply by snow or ice density
        η_k  = Δt / (c_i[index]*Δh[min(index+1, col*N_layers)])
        η_k /= ρ_s + (k > N_s) * (ρ_i - ρ_s) # conditional is for ice density
        if k == 0
            maindiag[index] = dF_0[col] - K̄[index]
            rhs[index]      = dF_0[col]*T_old[index] - F_0[col]
        else
            maindiag[index] = 1 + η_k*(K̄[index-1] + K̄[index])
            rhs[index]      = T_old[index] #- (k > N_s) * 
        end

        if k > N_s
            rhs[index] += η_k * I_pen[(col-1)*N_i + k - N_s]
            if k == N_layers - 1
                rhs[index] += η_k * 0.5K[index]*T_frz
            end
        end
    end
    return nothing
end

# Produces the first sub and super diagonals of the matrices for the tridiagonal solve and temperature changes
@inline function generate_subdiag_supdiag(N_c, N_s, N_layers, Δh, c_i, K̄, subdiag, supdiag, T_old, Δt)

    for index in 1:(N_c*(N_layers-1))
        col = ((index-1) ÷ (N_layers - 1)) + 1 # current column value
        k   = (index-1) % (N_layers - 1) # current layer value, from 2 to end for subdiag (-2)

        sub_adj_index = (col-1)*N_layers + k + 2
        sup_adj_index = (col-1)*N_layers + k + 1

        subdiag[index] = 0.0
        supdiag[index] = 0.0

        η_k_sub  = Δt / (c_i[sub_adj_index]*Δh[min(sub_adj_index+1, col*N_layers)])
        η_k_sub /= ρ_s + (k > N_s-1) * (ρ_i - ρ_s) # conditional is for ice density

        η_k_sup  = Δt / (c_i[sup_adj_index]*Δh[min(sup_adj_index+1, col*N_layers)])
        η_k_sup /= ρ_s + (k > N_s) * (ρ_i - ρ_s) # conditional is for ice density

        subdiag[index] = -η_k_sub * K̄[sub_adj_index-1]
        supdiag[index] = K̄[sup_adj_index]
        if k != 0
            supdiag[index] *= -η_k_sup
        end

    end
    return nothing
end

# Solves a large number of tridiagonal systems in batch
function batched_tridiagonal_solve(x, N, count, maindiag, subdiag, supdiag)

    for c in 1:count

        x_n        = view(x, ((c-1)*(N+1)+1):c*(N+1))
        maindiag_n = view(maindiag, ((c-1)*(N+1)+1):c*(N+1))
        subdiag_n  = view(subdiag, ((c-1)*N+1):c*N)
        supdiag_n  = view(supdiag, ((c-1)*N+1):c*N)

        tridiagonal_solve(x_n, N, maindiag_n, subdiag_n, supdiag_n)
    end
end

# Solves a tridiagonal system using the tridiagonal matrix algorithm (aka Thomas algorithm)
# x contains the original rhs values which are permuted
# the subdiag and supdiag entries are also permuted
@inline function tridiagonal_solve(x, N, maindiag, subdiag, supdiag)

    @inbounds for i in 2:(N+1)

        w           = (subdiag[i-1]/maindiag[i-1])
        maindiag[i] = maindiag[i] - w*supdiag[i-1]
        x[i]        = x[i] - w*x[i-1]
    end

    x[N+1] = x[N+1]/maindiag[N+1]

    @inbounds for i in N:-1:1

        x[i] = (x[i] - supdiag[i]*x[i+1])/maindiag[i]
    end

    return nothing

end

# Gets the melting point as a function of salinity
@inline function t_mlt(S)

    return 273.15 - 0.0592.*S - 9.37*(10^(-6)).*(S.^2) - 5.33*(10^(-7)).*(S.^3)

end

# Gets the thermal conductivity at this time step. (Maykut,1971)
# 2.03 is K_0, conductivity of fresh ice
# 0.13 is β, an empirical constant
@inline function generate_K(K, N_c, N_s, N_layers, H_s, S, T)
    #=
    for col in 1:N_c
        index = (col - 1) * N_layers
        # All layers. The structure is snow + (condoitional for ice surface) + (conditional for ice)
        for k in 1:N_layers
            K[index + k] = 0.3 + ((H_s[col] < puny) * (k == 1) * 1.73) + (k > (N_s + 1)) * (1.73 + (0.13S[k])/T[index + k])
        end
    end
    =#
    for index in 1:(N_c*N_layers)
        col      = ((index-1) ÷ N_layers) + 1
        k        = (index-1) % N_layers
        #          snow    ice surface condtional                 conditional for interior ice
        K[index] = 0.3 + ((H_s[col] < puny) * (k == 0) * 1.73) + (k > N_s) * (1.73 + (0.13S[index])/T[index])
    end
    
    return nothing
end

# gets the specific heat of sea ice
@inline function generate_c_i(c_i, N_c, N_s, N_layers, S, T_old, T_new)
    #=
    for col in 1:N_c
        index = (col - 1) * N_layers
        # Snow and ice surface both match fresh ice, conditional for deeper ice:
        for k in 1:N_layers
            c_i[index + k] = c_0 + (k > (N_s + 1)) * (L_0*μ*S[index + k])/(T_old[index + k]*T_new[index + k])
        end
    end
    =#
    for index in 1:(N_c*N_layers)
        col        = ((index-1) ÷ N_layers) + 1
        k          = (index-1) % N_layers
        #            snow/fresh ice     conditional for interior ice
        c_i[index] = c_0 + (k > N_s) * (L_0*μ*S[index])/(T_old[index]*T_new[index])
    end

    return nothing
end