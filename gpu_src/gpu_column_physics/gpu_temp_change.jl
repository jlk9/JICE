# Written by Joseph Kump (josek97@utexas.edu)
# Computes the thermodynamic temperature changes in once column
# of sea ice

# Runs a single time step of the temperature changes using FDM
@inline function step_temp_change(N_c, N_i, N_s, N_layers, H_s, S, T_frz, Δh, T_old, T_new, c_i, K, K̄, I_pen, F_0, dF_0, maindiag, subdiag, supdiag, Δt, step)

    #=
    # Getting the average thicknesses of each layer:
    for i in 1:(jcolumn.N_i+jcolumn.N_s)
        jcolumn.Δh̄[i] = (jcolumn.Δh[i] + jcolumn.Δh[i+1]) ./ 2
    end
    =#
    # Ice thermal conductivity (length N_i+1)
    generate_K(K, N_c, N_s, N_layers, H_s, S, T_old)
    
    # Specific heat (length N_i+1), generated by formula
    generate_c_i(c_i, N_c, N_s, N_layers, S, T_old, T_new)
    
    # Get the Matrix and RHS:
    generate_maindiag_rhs(N_c, N_i, N_s, N_layers, H_s, Δh, c_i, K, K̄, dF_0[(step-1)*N_c+1:step*N_c], F_0, T_frz, I_pen, maindiag, T_new, T_old, Δt)
    generate_subdiag_supdiag(N_c, N_i, N_s, N_layers, H_s, Δh, c_i, K, K̄, dF_0, F_0, T_frz, I_pen, subdiag, supdiag, T_old, Δt)
    #generate_matrix_rhs(N_i, N_s, H_s, Δh, c_i, K, K̄, dF_0, F_0, T_frz, I_pen, maindiag, subdiag, supdiag, T_old, T_new, Δt)
    #=
    #mat = Tridiagonal(subdiag, maindiag, supdiag)

    #println(c_i)
    #println(K)
    #println(T_old)
    #println(mat)
    #println(T_new)
    # Calculate new time step
    tridiagonal_solve(T_new, N_i+N_s, maindiag, subdiag, supdiag)

    # Shift surface temperature back if no snow:
    if H_s < puny && N_s > 0
        T_new[1]     = T_new[N_s+1]
        T_new[N_s+1] = 0.0
    end
    =#
    return nothing
end

# Produces the main diagonal of the matrices for the tridiagonal solve and temperature changes
@inline function generate_maindiag_rhs(N_c, N_i, N_s, N_layers, H_s, Δh, c_i, K, K̄, dF_0, F_0, T_frz, I_pen, maindiag, rhs, T_old, Δt)

    #=
    # First get K̄:
    for col in 1:N_c
        index = (col-1) * N_layers
        for k in 1:(N_layers-1)
            K̄[index+k] = (2*K[index+k]*K[index+k+1]) / (Δh[index+k+1]*K[index+k] + Δh[index+k]*K[index+k+1])
        end
        K̄[index+N_layers] = 0.5K[index+N_layers]
    end
    =#
    # First get K̄, then fill in entries of maindiag::
    for index in 1:(N_c*N_layers)
        col = ((index-1) ÷ N_layers) + 1
        k   = (index-1) % N_layers

        if index % N_layers == 0
            K̄[index] = 0.5K[index]
        else
            K̄[index] = (2*K[index]*K[index+1]) / (Δh[index+1]*K[index] + Δh[index]*K[index+1])
        end

        # Initialize maindiag as 1's, rhs as 0's:
        maindiag[index] = 1.0
        rhs[index]      = 0.0

        # Compute η_k (Δh index special for lower boundary), then multiply by snow or ice density
        η_k  = Δt / (c_i[index]*Δh[min(index+1, col*N_layers)])
        η_k /= ρ_s + (k > N_s) * (ρ_i - ρ_s) # conditional is for ice density
        if k == 0
            maindiag[index] = dF_0[col] - K̄[index]
            rhs[index]      = dF_0[col]*T_old[index] - F_0[col]
        else
            maindiag[index] = 1 + η_k*(K̄[index-1] + K̄[index])
            rhs[index]      = T_old[index] #- (k > N_s) * 
        end

        if k > N_s
            rhs[index] += η_k * I_pen[(col-1)*N_i + k - N_s]
            if k == N_layers - 1
                rhs[index] += η_k * 0.5K[index]*T_frz
            end
        end
    end
    return nothing
end

# Produces the first sub and super diagonals of the matrices for the tridiagonal solve and temperature changes
@inline function generate_subdiag_supdiag(N_c, N_i, N_s, N_layers, H_s, Δh, c_i, K, K̄, dF_0, F_0, T_frz, I_pen, subdiag, supdiag, T_old, Δt)

    for index in 1:(N_c*(N_layers-1))
        col = ((index-1) ÷ (N_layers - 1)) + 1 # current column value
        k   = (index-1) % (N_layers - 1) # current layer value, from 2 to end for subdiag (-2)

        sub_adj_index = (col-1)*N_layers + k + 2
        sup_adj_index = (col-1)*N_layers + k + 1

        subdiag[index] = 0.0
        supdiag[index] = 0.0

        η_k_sub  = Δt / (c_i[sub_adj_index]*Δh[min(sub_adj_index+1, col*N_layers)])
        η_k_sub /= ρ_s + (k > N_s-1) * (ρ_i - ρ_s) # conditional is for ice density

        η_k_sup  = Δt / (c_i[sup_adj_index]*Δh[min(sup_adj_index+1, col*N_layers)])
        η_k_sup /= ρ_s + (k > N_s) * (ρ_i - ρ_s) # conditional is for ice density

        subdiag[index] = -η_k_sub * K̄[sub_adj_index-1]
        supdiag[index] = -K̄[sup_adj_index]
        if k != 0
            supdiag[index] *= η_k_sup
        end

    end
    return nothing
end

# Generates the implicit (tridiagonal) matrix for time step T_nplus
# I think this matrix is stable in the Thomas algorithm because it is
# diagonally dominant
# Based on formation of tridiagonal matrix in icepack_therm_bl99
@inline function generate_matrix_rhs(N_i, N_s, H_s, Δh, c_i, K, K̄, dF_0, F_0, T_frz, I_pen, maindiag, subdiag, supdiag, T_old, rhs, Δt)

    # Getting K̄ (length N_i):
    # Trick: we'll move the surface temp to the N_s+1 layer when H_s < puny
    if H_s < puny
        K[N_s+1] = K[1]
    end
    for k in 1:(N_i+N_s)
        K̄[k] = (2*K[k]*K[k+1]) / (Δh[k+1]*K[k] + Δh[k]*K[k+1])
    end

    # Set up dummy equations for when we don't need to solve for the surface or snow temp:
    for k in 1:(N_s+1)

        maindiag[k] = 1.0
        subdiag[k]  = 0.0
        supdiag[k]  = 0.0
        rhs[k]      = 0.0
    end

    # Top surface, based on (50) in science guide and line 1074 in icepack_therm_bl99
    if T_old[1] < 0
        k = 1
        if H_s < puny
            k += N_s
        end

        maindiag[k] = (dF_0 - K̄[k])
        supdiag[k]  = K̄[k]
        rhs[k]      = dF_0*T_old[1] - F_0
    end
    
    # Interior snow layers, based on (52) in science guide
    if H_s >= puny
        for k in 2:(N_s+1)
            η_k          = Δt / (ρ_s*c_i[k]*Δh[k+1])
            maindiag[k]  = 1 + η_k*(K̄[k-1] + K̄[k])
            subdiag[k-1] = -η_k*K̄[k-1]
            supdiag[k]   = -η_k*K̄[k]
            rhs[k]       = T_old[k]
        end
    end

    # Interior ice layers, based on (52) in science guide
    for k in (N_s+2):(N_i+N_s)
        η_k          = Δt / (ρ_i*c_i[k]*Δh[k+1])
        #maindiag[k]  = 1 + η_k*(K̄[k-1] + K̄[k])
        maindiag[k] = η_k
        subdiag[k-1] = -η_k*K̄[k-1]
        supdiag[k]   = -η_k*K̄[k]
        rhs[k]       = T_old[k] + η_k*I_pen[k-N_s-1]
    end

    # Bottom surface
    η_end               = Δt / (ρ_i*c_i[N_i+N_s+1]*Δh[N_i+N_s+1])
    maindiag[N_i+N_s+1] = 1 + η_end*(K̄[N_i+N_s] + 0.5*K[N_i+N_s+1]) #1 + η_Ni*(K[N_i] + K[N_i+1])
    subdiag[N_i+N_s]    = -η_end*K̄[N_i+N_s]
    rhs[N_i+N_s+1]     += η_end*(I_pen[N_i] + 0.5*K[N_i+N_s+1]*T_frz) #η_Ni*(I_pen[N_i] + K[N_i+1]*T_frz)

    return nothing
end

# Solves a tridiagonal system using the tridiagonal matrix algorithm (aka Thomas algorithm)
# x contains the original rhs values which are permuted
# the subdiag and supdiag entries are also permuted
@inline function tridiagonal_solve(x, N, maindiag, subdiag, supdiag)

    @inbounds for i in 2:(N+1)

        w           = (subdiag[i-1]/maindiag[i-1])
        maindiag[i] = maindiag[i] - w*supdiag[i-1]
        x[i]        = x[i] - w*x[i-1]
    end

    x[N+1] = x[N+1]/maindiag[N+1]

    @inbounds for i in N:-1:1

        x[i] = (x[i] - supdiag[i]*x[i+1])/maindiag[i]
    end

    return nothing

end

# Gets the melting point as a function of salinity
@inline function t_mlt(S)

    return 273.15 - 0.0592.*S - 9.37*(10^(-6)).*(S.^2) - 5.33*(10^(-7)).*(S.^3)

end

# Gets the thermal conductivity at this time step. (Maykut,1971)
# 2.03 is K_0, conductivity of fresh ice
# 0.13 is β, an empirical constant
@inline function generate_K(K, N_c, N_s, N_layers, H_s, S, T)
    #=
    for col in 1:N_c
        index = (col - 1) * N_layers
        # All layers. The structure is snow + (condoitional for ice surface) + (conditional for ice)
        for k in 1:N_layers
            K[index + k] = 0.3 + ((H_s[col] < puny) * (k == 1) * 1.73) + (k > (N_s + 1)) * (1.73 + (0.13S[k])/T[index + k])
        end
    end
    =#
    for index in 1:(N_c*N_layers)
        col      = ((index-1) ÷ N_layers) + 1
        k        = (index-1) % N_layers
        #          snow    ice surface condtional                 conditional for interior ice
        K[index] = 0.3 + ((H_s[col] < puny) * (k == 0) * 1.73) + (k > N_s) * (1.73 + (0.13S[index])/T[index])
    end
    
    return nothing
end

# gets the specific heat of sea ice
@inline function generate_c_i(c_i, N_c, N_s, N_layers, S, T_old, T_new)
    #=
    for col in 1:N_c
        index = (col - 1) * N_layers
        # Snow and ice surface both match fresh ice, conditional for deeper ice:
        for k in 1:N_layers
            c_i[index + k] = c_0 + (k > (N_s + 1)) * (L_0*μ*S[index + k])/(T_old[index + k]*T_new[index + k])
        end
    end
    =#
    for index in 1:(N_c*N_layers)
        col        = ((index-1) ÷ N_layers) + 1
        k          = (index-1) % N_layers
        #            snow/fresh ice     conditional for interior ice
        c_i[index] = c_0 + (k > N_s) * (L_0*μ*S[index])/(T_old[index]*T_new[index])
    end

    return nothing
end