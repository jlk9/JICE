
include("../gpu_src/gpu_atmosphere_model/gpu_atmodel_struct.jl")
include("../gpu_src/gpu_column_physics/gpu_run_ice_column.jl")

using BenchmarkTools, CUDA

function test_model_run(N_t, N_c, N_i, N_s, H_i, H_s, T_frz, Δt, u_star, T_w, T_0, F_SWvdr, F_SWidr, F_SWvdf, F_SWidf, F_Ld, T_a, Θ_a, ρ_a, Q_a, c_p, U_a, onDevice)

    @btime atmodels = initialize_ATModelArrays(N_t, N_c, F_SWvdr, F_SWidr, F_SWvdf, F_SWidf, F_Ld, T_a, Θ_a, ρ_a, Q_a, c_p, U_a, onDevice)
    @btime jarrays  = initialize_JICEColumnArrays(N_t, N_c, N_i, N_s, H_i, H_s, T_frz, Δt, u_star, T_w, T_0, onDevice)

    @btime run_ice_column(jarrays, atmodels)

    return jarrays.T_nplus
end


N_t    = 1
N_c    = 100000
N_i    = 5
N_s    = 2
H_i    = 2.0 .+ zeros(Float64, N_c)
H_s    = 0.10 .+ zeros(Float64, N_c)
T_frz  = 271.35 - 273.15
T_0    = repeat([-21.0, -20.5, -20.0, -19.0, -14.5, -10.0, -5.5, -1.0], N_c)
Δt     = 1.0
u_star = 0.0005 # recommended minimum value of u_star in CICE
T_w    = (274.47 - 273.15) .+ zeros(Float64, N_c) # typical temp in C for sea surface in arctic

# "Educated" guess for some normal atmospheric values
F_Ld    = 10.0 .+ zeros(Float64, N_c)
F_SWvdr = 120.0 .+ zeros(Float64, N_c)
F_SWidr = 0.0 .+ zeros(Float64, N_c)
F_SWvdf = 0.0 .+ zeros(Float64, N_c)
F_SWidf = 0.0 .+ zeros(Float64, N_c)
T_a     = -34.0 .+ zeros(Float64, N_c)
Θ_a     = (T_a*(1000.0/1045.6)^0.286) .+ zeros(Float64, N_c)
ρ_a     = 1.4224 .+ zeros(Float64, N_c)
Q_a     = 0.005 .+ zeros(Float64, N_c) #?
c_p     = 0.7171 .+ zeros(Float64, N_c)
U_a     = zeros(Float64, 3*N_c)

onDevice = CUDA.has_cuda()
println("Performance for: initializing atmodel, initializing jarrays, running on 10^5 col for 1 time step:")
atmodels = initialize_ATModelArrays(N_t, N_c, F_SWvdr, F_SWidr, F_SWvdf, F_SWidf, F_Ld, T_a, Θ_a, ρ_a, Q_a, c_p, U_a, onDevice)
jarrays  = initialize_JICEColumnArrays(N_t, N_c, N_i, N_s, H_i, H_s, T_frz, Δt, u_star, T_w, T_0, onDevice)

#@benchmark CUDA.@sync initialize_ATModelArrays(N_t, N_c, F_SWvdr, F_SWidr, F_SWvdf, F_SWidf, F_Ld, T_a, Θ_a, ρ_a, Q_a, c_p, U_a, onDevice)
#@benchmark CUDA.@sync initialize_JICEColumnArrays(N_t, N_c, N_i, N_s, H_i, H_s, T_frz, Δt, u_star, T_w, T_0, onDevice)

println("Timing/memory for: albedo and surface flux, then temperature change:")
#=
CUDA.@time step_surface_flux(jarrays.N_c, jarrays.N_i, jarrays.N_layers, jarrays.α_vdr_i, jarrays.α_idr_i, jarrays.α_vdf_i, jarrays.α_idf_i, jarrays.α_vdr_s, jarrays.α_idr_s, jarrays.α_vdf_s, jarrays.α_idf_s,
                      jarrays.T_n, jarrays.H_i, jarrays.H_s,
                      jarrays.F_0, jarrays.dF_0, jarrays.F_Lu, jarrays.F_s, jarrays.F_l, jarrays.dF_Lu, jarrays.dF_s, jarrays.dF_l,
                      atmodels.F_SWvdr, atmodels.F_SWidr, atmodels.F_SWvdf, atmodels.F_SWidf, atmodels.F_Ld, jarrays.I_pen,
                      atmodels.c_u, atmodels.c_Θ, atmodels.c_q, atmodels.U_a, atmodels.Θ_a, atmodels.Q_a, atmodels.atm_u_star,
                      atmodels.ρ_a, atmodels.c_p, atmodels.Q_sfc, atmodels.F_SWsfc, atmodels.F_SWpen, jarrays.onGPU)
=#
    # Computes the temperature changes at this step

#CUDA.@time step_temp_change(jarrays.N_c, jarrays.N_i, jarrays.N_s, jarrays.N_layers, jarrays.H_s, jarrays.S, jarrays.T_frz, jarrays.Δh, jarrays.T_n,
#                     jarrays.T_nplus, jarrays.c_i, jarrays.K, jarrays.K̄, jarrays.I_pen, jarrays.F_0, jarrays.dF_0,
#		     jarrays.maindiag, jarrays.subdiag, jarrays.supdiag, jarrays.Δt, jarrays.onGPU)

println("Albedo:")
CUDA.@time generate_α(jarrays.N_layers, jarrays.H_i, jarrays.α_vdr_i, jarrays.α_idr_i, jarrays.α_vdf_i, jarrays.α_idf_i, jarrays.α_vdr_s, jarrays.α_idr_s, jarrays.α_vdf_s, jarrays.α_idf_s, jarrays.T_sfc)

println("Set flux values:")
# Compute atmospheric fluxes dependent on ice:
CUDA.@time set_atm_flux_values(jarrays.N_c, jarrays.N_layers, jarrays.F_Lu, jarrays.F_s, jarrays.F_l, jarrays.dF_Lu, jarrays.dF_s, jarrays.dF_l, atmodels.c_u, atmodels.c_Θ, atmodels.c_q, atmodels.U_a, atmodels.Θ_a, atmodels.Q_a, atmodels.atm_u_star, atmodels.ρ_a, atmodels.c_p, atmodels.Q_sfc, jarrays.T_sfc, jarrays.H_i, onDevice)

numblocks = ceil(Int, jarrays.N_layers*jarrays.N_c/256)
# Ice thermal conductivity (length N_i+1)
println("Generate K:")
CUDA.@time @cuda threads=256 blocks=numblocks gpu_generate_K(jarrays.K, jarrays.N_c, jarrays.N_s, jarrays.N_layers, jarrays.S, jarrays.T_n)
# Specific heat (length N_i+1), generated by formula
println("Generate c_i")
CUDA.@time @cuda threads=256 blocks=numblocks gpu_generate_c_i(jarrays.c_i, jarrays.N_c, jarrays.N_s, jarrays.N_layers, jarrays.S, jarrays.T_n, jarrays.T_nplus)

# Get the Matrix and RHS:
println("Generate mat and rhs:")
CUDA.@time @cuda threads=256 blocks=numblocks gpu_generate_matrix_rhs(jarrays.N_c, jarrays.N_i, jarrays.N_s, jarrays.N_layers, jarrays.Δh, jarrays.c_i, jarrays.K, jarrays.K̄, jarrays.dF_0, jarrays.F_0, jarrays.T_frz, jarrays.I_pen, jarrays.maindiag, jarrays.subdiag, jarrays.supdiag, jarrays.T_nplus, jarrays.T_n, jarrays.Δt)
println("Tridiagonal solve:")
CUDA.@time CUSPARSE.gtsv2!(jarrays.subdiag, jarrays.maindiag, jarrays.supdiag, jarrays.T_nplus)







println("And now doing them both again for good measure:")
atmodels = initialize_ATModelArrays(N_t, N_c, F_SWvdr, F_SWidr, F_SWvdf, F_SWidf, F_Ld, T_a, Θ_a, ρ_a, Q_a, c_p, U_a, onDevice)
jarrays  = initialize_JICEColumnArrays(N_t, N_c, N_i, N_s, H_i, H_s, T_frz, Δt, u_star, T_w, T_0, onDevice)

println("Albedo:")
CUDA.@time generate_α(jarrays.N_layers, jarrays.H_i, jarrays.α_vdr_i, jarrays.α_idr_i, jarrays.α_vdf_i, jarrays.α_idf_i, jarrays.α_vdr_s, jarrays.α_idr_s, jarrays.α_vdf_s, jarrays.α_idf_s, jarrays.T_sfc)

println("Set flux values:")
# Compute atmospheric fluxes dependent on ice:
CUDA.@time set_atm_flux_values(jarrays.N_c, jarrays.N_layers, jarrays.F_Lu, jarrays.F_s, jarrays.F_l, jarrays.dF_Lu, jarrays.dF_s, jarrays.dF_l, atmodels.c_u, atmodels.c_Θ, atmodels.c_q, atmodels.U_a, atmodels.Θ_a, atmodels.Q_a, atmodels.atm_u_star, atmodels.ρ_a, atmodels.c_p, atmodels.Q_sfc, jarrays.T_sfc, jarrays.H_i, onDevice)

numblocks = ceil(Int, jarrays.N_layers*jarrays.N_c/256)
# Ice thermal conductivity (length N_i+1)
println("Generate K:")
CUDA.@time @cuda threads=256 blocks=numblocks gpu_generate_K(jarrays.K, jarrays.N_c, jarrays.N_s, jarrays.N_layers, jarrays.S, jarrays.T_n)
# Specific heat (length N_i+1), generated by formula
println("Generate c_i")
CUDA.@time @cuda threads=256 blocks=numblocks gpu_generate_c_i(jarrays.c_i, jarrays.N_c, jarrays.N_s, jarrays.N_layers, jarrays.S, jarrays.T_n, jarrays.T_nplus)

# Get the Matrix and RHS:
println("Generate mat and rhs:")
CUDA.@time @cuda threads=256 blocks=numblocks gpu_generate_matrix_rhs(jarrays.N_c, jarrays.N_i, jarrays.N_s, jarrays.N_layers, jarrays.Δh, jarrays.c_i, jarrays.K, jarrays.K̄, jarrays.dF_0, jarrays.F_0, jarrays.T_frz, jarrays.I_pen, jarrays.maindiag, jarrays.subdiag, jarrays.supdiag, jarrays.T_nplus, jarrays.T_n, jarrays.Δt)
println("Tridiagonal solve:")
CUDA.@time CUSPARSE.gtsv2!(jarrays.subdiag, jarrays.maindiag, jarrays.supdiag, jarrays.T_nplus)


println("For reference, let's test the CPU version step by step:")

N_t    = 1
N_c    = 100000
N_i    = 5
N_s    = 2
H_i    = 2.0 .+ zeros(Float64, N_c)
H_s    = 0.10 .+ zeros(Float64, N_c)
T_frz  = 271.35 - 273.15
T_0    = repeat([-21.0, -20.5, -20.0, -19.0, -14.5, -10.0, -5.5, -1.0], N_c)
Δt     = 1.0
u_star = 0.0005 # recommended minimum value of u_star in CICE
T_w    = (274.47 - 273.15) .+ zeros(Float64, N_c) # typical temp in C for sea surface in arctic

# "Educated" guess for some normal atmospheric values
F_Ld    = 10.0 .+ zeros(Float64, N_c)
F_SWvdr = 120.0 .+ zeros(Float64, N_c)
F_SWidr = 0.0 .+ zeros(Float64, N_c)
F_SWvdf = 0.0 .+ zeros(Float64, N_c)
F_SWidf = 0.0 .+ zeros(Float64, N_c)
T_a     = -34.0 .+ zeros(Float64, N_c)
Θ_a     = (T_a*(1000.0/1045.6)^0.286) .+ zeros(Float64, N_c)
ρ_a     = 1.4224 .+ zeros(Float64, N_c)
Q_a     = 0.005 .+ zeros(Float64, N_c) #?
c_p     = 0.7171 .+ zeros(Float64, N_c)
U_a     = zeros(Float64, 3*N_c)

onDevice = false
atmodels = initialize_ATModelArrays(N_t, N_c, F_SWvdr, F_SWidr, F_SWvdf, F_SWidf, F_Ld, T_a, Θ_a, ρ_a, Q_a, c_p, U_a, onDevice)
jarrays  = initialize_JICEColumnArrays(N_t, N_c, N_i, N_s, H_i, H_s, T_frz, Δt, u_star, T_w, T_0, onDevice)

println("Albedo:")
@btime generate_α(jarrays.N_layers, jarrays.H_i, jarrays.α_vdr_i, jarrays.α_idr_i, jarrays.α_vdf_i, jarrays.α_idf_i, jarrays.α_vdr_s, jarrays.α_idr_s, jarrays.α_vdf_s, jarrays.α_idf_s, jarrays.T_sfc)

println("Set flux values:")
# Compute atmospheric fluxes dependent on ice:
@btime set_atm_flux_values(jarrays.N_c, jarrays.N_layers, jarrays.F_Lu, jarrays.F_s, jarrays.F_l, jarrays.dF_Lu, jarrays.dF_s, jarrays.dF_l, atmodels.c_u, atmodels.c_Θ, atmodels.c_q, atmodels.U_a, atmodels.Θ_a, atmodels.Q_a, atmodels.atm_u_star, atmodels.ρ_a, atmodels.c_p, atmodels.Q_sfc, jarrays.T_sfc, jarrays.H_i, onDevice)

# Ice thermal conductivity (length N_i+1)
println("Generate K:")
@btime generate_K(jarrays.K, jarrays.N_c, jarrays.N_s, jarrays.N_layers, jarrays.S, jarrays.T_n)
# Specific heat (length N_i+1), generated by formula
println("Generate c_i")
@btime generate_c_i(jarrays.c_i, jarrays.N_c, jarrays.N_s, jarrays.N_layers, jarrays.S, jarrays.T_n, jarrays.T_nplus)

# Get the Matrix and RHS:
println("Generate mat and rhs:")
@btime generate_matrix_rhs(jarrays.N_c, jarrays.N_i, jarrays.N_s, jarrays.N_layers, jarrays.Δh, jarrays.c_i, jarrays.K, jarrays.K̄, jarrays.dF_0, jarrays.F_0, jarrays.T_frz, jarrays.I_pen, jarrays.maindiag, jarrays.subdiag, jarrays.supdiag, jarrays.T_nplus, jarrays.T_n, jarrays.Δt)
println("Tridiagonal solve:")
@btime batched_tridiagonal_solve(jarrays.T_nplus, jarrays.N_layers-1, jarrays.N_c, jarrays.maindiag, jarrays.subdiag, jarrays.supdiag)

println("And doing these again:")
atmodels = initialize_ATModelArrays(N_t, N_c, F_SWvdr, F_SWidr, F_SWvdf, F_SWidf, F_Ld, T_a, Θ_a, ρ_a, Q_a, c_p, U_a, onDevice)
jarrays  = initialize_JICEColumnArrays(N_t, N_c, N_i, N_s, H_i, H_s, T_frz, Δt, u_star, T_w, T_0, onDevice)

println("Albedo:")
@btime generate_α(jarrays.N_layers, jarrays.H_i, jarrays.α_vdr_i, jarrays.α_idr_i, jarrays.α_vdf_i, jarrays.α_idf_i, jarrays.α_vdr_s, jarrays.α_idr_s, jarrays.α_vdf_s, jarrays.α_idf_s, jarrays.T_sfc)

println("Set flux values:")
# Compute atmospheric fluxes dependent on ice:
@btime set_atm_flux_values(jarrays.N_c, jarrays.N_layers, jarrays.F_Lu, jarrays.F_s, jarrays.F_l, jarrays.dF_Lu, jarrays.dF_s, jarrays.dF_l, atmodels.c_u, atmodels.c_Θ, atmodels.c_q, atmodels.U_a, atmodels.Θ_a, atmodels.Q_a, atmodels.atm_u_star, atmodels.ρ_a, atmodels.c_p, atmodels.Q_sfc, jarrays.T_sfc, jarrays.H_i, onDevice)

# Ice thermal conductivity (length N_i+1)
println("Generate K:")
@btime generate_K(jarrays.K, jarrays.N_c, jarrays.N_s, jarrays.N_layers, jarrays.S, jarrays.T_n)
# Specific heat (length N_i+1), generated by formula
println("Generate c_i")
@btime generate_c_i(jarrays.c_i, jarrays.N_c, jarrays.N_s, jarrays.N_layers, jarrays.S, jarrays.T_n, jarrays.T_nplus)

# Get the Matrix and RHS:
println("Generate mat and rhs:")
@btime generate_matrix_rhs(jarrays.N_c, jarrays.N_i, jarrays.N_s, jarrays.N_layers, jarrays.Δh, jarrays.c_i, jarrays.K, jarrays.K̄, jarrays.dF_0, jarrays.F_0, jarrays.T_frz, jarrays.I_pen, jarrays.maindiag, jarrays.subdiag, jarrays.supdiag, jarrays.T_nplus, jarrays.T_n, jarrays.Δt)
println("Tridiagonal solve:")
@btime batched_tridiagonal_solve(jarrays.T_nplus, jarrays.N_layers-1, jarrays.N_c, jarrays.maindiag, jarrays.subdiag, jarrays.supdiag)
